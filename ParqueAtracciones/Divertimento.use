model Divertimento

class Parque
end

class CRA
operations
    averiaDetectada(trans: Transporte, atr: Atraccion): Boolean
    begin
        declare a: Averia, op: Operario, return: Boolean;
        return := self.operarios->select(op | op.dispositivo.opDisponible)->notEmpty();
        if self.averia->isEmpty() then
            a := new Averia between (trans, self);
            if return then
                op := self.operarios->any(op | op.dispositivo.opDisponible);
                insert(op, a) into Atiende;
                op.dispositivo.sendIssue(atr.numeroCalle, trans.numero);
                op.dispositivo.opDisponible;
            end
        else
            a := self.averia->any(true);
            if return then
                op := self.operarios->any(op | op.dispositivo.opDisponible);
                insert(op, a) into Atiende;
                op.dispositivo.sendIssue(atr.numeroCalle, trans.numero);
                op.dispositivo.opDisponible;
            end
        end
    end
    pre transportePerteneceAtraccion: atr.transportes->includes(trans)
    pre mismoParque: atr.parque = self.parque
    post nuevaAveria: Averia.allInstances->size() = Averia.allInstances@pre->size() + 1
end

abstract class Transporte
attributes
    numero: Integer
operations
    -- Notification operations
    -- Si en un momento determinado se detectara pérdida de anclaje,
    -- el correspondiente vehículo se lo comunicaría a la Central Receptora de Averías
    -- (CRA) y también a la atracción de la que forma parte dicho vehículo
    brokenTransport()
    begin
        self.atraccion.brokenComponent();
        self.atraccion.parque.cra.averiaDetectada(self, self.atraccion)
    end
    pre noUltimoVagon: self.oclIsTypeOf(Vagon) implies self.oclAsType(Vagon).posterior -> notEmpty()
    fixedTransport()
    begin
        self.atraccion.fixedComponent(); -- Esta así porque quiero probar estados
    end
    pre existeAveria: self.averia->notEmpty
    pre averiaAtendida: self.averia.atendida
    post AveriaEliminada: self.averia->isEmpty


statemachines
    psm Estado
        states
            s: initial
            Averiado
            Funcionando
        transitions
            s -> Funcionando
            Funcionando -> Averiado { brokenTransport() }
            Averiado -> Funcionando { fixedTransport() }
            Averiado -> Averiado { brokenTransport() }
    end
end

class Vagon < Transporte
end

class Vehiculo < Transporte
end

abstract class Atraccion
attributes
    numeroCalle: Integer
operations
    fixedComponent() -- When a component is fixed and notifies this class
    begin
    end
    brokenComponent() -- When a component is broken and notifies this class
    begin
    end
statemachines
    psm Estado
        states
            s: initial
            Funcionando
            Esperando
        transitions
            s -> Funcionando
            Funcionando -> Esperando { brokenComponent() }
            Esperando -> Funcionando { [self.transportes->collect(averia)->size()=1] fixedComponent() }
            Esperando -> Esperando { brokenComponent() }
            Esperando -> Esperando { [self.transportes->collect(averia)->size()>1] fixedComponent() }
    end
end

class Noria < Atraccion
end

class MRusa < Atraccion
end

class Operario
operations
    workerBusy()
    begin
        self.averiaAtendida.beginIssue();
    end
    workerReleased()
    begin
        self.averiaAtendida.finishedIssue();
    end
statemachines
    psm Estado
        states
            s: initial
            Libre
            Ocupado
        transitions
            s -> Libre
            Libre -> Ocupado { workerBusy() }
            Ocupado -> Libre { workerReleased() }
    end
end

class Dispositivo
attributes
    averiasAtendidas: Integer init: 0
    opDisponible : Boolean init: false --derive = operario.averiaAtendida->isEmpty()
operations
    sendIssue(calle: Integer, transNumero: Integer)
    begin
        self.operario.workerBusy();
    end
    pre operarioLibre: opDisponible
    post operarioOcupado: not opDisponible

    issueSolved()
    begin
        self.operario.workerReleased();
        self.averiasAtendidas := self.averiasAtendidas + 1;
    end
    pre trabajadorOcupado: not self.opDisponible
    post averiaIncrementada: self.averiasAtendidas = self.averiasAtendidas@pre + 1
    post trabajadorLibre: self.opDisponible
end

associationclass Averia between
Transporte [*] role transporte
CRA [0..1] role cra
attributes
    atendida : Boolean derive = operario->notEmpty()
operations
    beginIssue()
    begin
    end
    finishedIssue()
    begin
    end

statemachines
    psm Gestion
        states
            s: initial
            Pendiente
            Procesando
            Finalizado
        transitions
            s -> Pendiente
            Pendiente -> Procesando { beginIssue() }
            Procesando -> Finalizado { finishedIssue() }
    end
end

class Detector
end

association Posee between
    Parque [1] role parque
    CRA [1] role cra
end

association Trabajan between
    CRA [1] role cra
    Operario [1..*] role operarios
end

association Atiende between
    Operario [0..1] role operario
    Averia [0..1] role averiaAtendida
end

composition Existen between
    Parque [1] role parque
    Atraccion [1..*] role atracciones
end

aggregation Compuesta between
    Atraccion [1] role atraccion
    Transporte [1..*] role transportes
end

association Poseedor between
    Operario [1] role operario
    Dispositivo [1] role dispositivo
end

association Contiene between
    Detector [1] role detector
    Transporte [1] role transporte
end

association Anclado between
    Vagon [0..1] role anterior
    Vagon [0..1] role posterior
end

constraints
context Averia
inv MismaCRAOperarios:
    self.operario.cra = self.cra

inv MismaCRATransporte:
    self.transporte.atraccion.parque.cra = self.cra

context Atraccion
-- por algun motivo estas dos restricciones al estar juntas dan true
-- casi siempre (a pesar de tener un and entre ellas)
-- separadas en 2 funcionan
inv siNoriaEntoncesVehiculos:
    self.oclIsTypeOf(Noria) implies transportes.forAll(t | t.oclIsTypeOf(Vehiculo))
inv siMRusaEntoncesVagones:
    self.oclIsTypeOf(MRusa) implies transportes.forAll(t | t.oclIsTypeOf(Vagon))

context Vagon inv noAncladoASiMismo:
    posterior <> anterior or
    (self.anterior->size() = 0 and self.posterior->size() = 0)
    -- Si no se añade el size de anterior y posterior, al ser Undefined
    -- anterior y posterior, peta porque son "iguales"
